// 
// /Users/steve/MPLABXProjects/Leawood/PowerSensor-ATMEGA1608.X/Stimuli.scl
// Generated by Stimulus MPLAB X
// Mon Apr 10 18:39:23 CEST 2023
// 


configuration for "atmega1608" is
end configuration;

testbench for "atmega1608" is
begin
    // Register Injection (message-based)
    XBEE_DOUT: process is
        file     data_file_USART0_RXDATAL  : text;
        variable pkt_line_USART0_RXDATAL   : line;
        variable status_USART0_RXDATAL     : file_open_status;
        variable read_ok_USART0_RXDATAL    : boolean;
        variable waitime_USART0_RXDATAL  : time;
        variable rand_lower_USART0_RXDATAL,
                 rand_upper_USART0_RXDATAL : integer;
        variable rand_unit_USART0_RXDATAL  : string;
        variable randime_USART0_RXDATAL  : time;
        variable rand_seed1_USART0_RXDATAL : integer := 24372;
        variable rand_seed2_USART0_RXDATAL : integer := 12598;
        variable packet_USART0_RXDATAL     : string;
        variable dummy_USART0_RXDATAL      : integer;
        variable new_packet_USART0_RXDATAL : boolean := true;
    begin
        file_open(status_USART0_RXDATAL, data_file_USART0_RXDATAL, "/Users/steve/MPLABXProjects/Leawood/PowerSensor-ATMEGA1608.X/xbee-dout.pkt", read_mode);
        if status_USART0_RXDATAL == open_ok then
            while endfile(data_file_USART0_RXDATAL) == false loop
                readline(data_file_USART0_RXDATAL, pkt_line_USART0_RXDATAL);
                // skip empty line and comment line
                if match(pkt_line_USART0_RXDATAL, "") == true then // do nothing
                elsif match(pkt_line_USART0_RXDATAL, "//") == true then // do nothing
                else
                    if match(pkt_line_USART0_RXDATAL, "wait ") == true then
                        read(pkt_line_USART0_RXDATAL, dummy_USART0_RXDATAL); // to consume 'wait' command
                        read(pkt_line_USART0_RXDATAL, waitime_USART0_RXDATAL);
                        wait for waitime_USART0_RXDATAL;
                        new_packet_USART0_RXDATAL := true;
                    elsif match(pkt_line_USART0_RXDATAL, "rand ") == true then
                        read(pkt_line_USART0_RXDATAL, dummy_USART0_RXDATAL); // to consume 'rand' command
                        read(pkt_line_USART0_RXDATAL, rand_lower_USART0_RXDATAL);
                        read(pkt_line_USART0_RXDATAL, rand_upper_USART0_RXDATAL);
                        read(pkt_line_USART0_RXDATAL, rand_unit_USART0_RXDATAL);
                        random_time(rand_lower_USART0_RXDATAL, rand_upper_USART0_RXDATAL, rand_unit_USART0_RXDATAL,
                                    rand_seed1_USART0_RXDATAL, rand_seed2_USART0_RXDATAL, randime_USART0_RXDATAL);
                        wait for randime_USART0_RXDATAL;
                        new_packet_USART0_RXDATAL := true;
                    else
                        if new_packet_USART0_RXDATAL == true then
                            packetin(pkt_line_USART0_RXDATAL, USART0_RXDATAL, false); // new packet
                            wait until USART0_RXDATAL_packet_done;
                            new_packet_USART0_RXDATAL := false;
                        else
                            packetin(pkt_line_USART0_RXDATAL, USART0_RXDATAL, true); // append to previous
                            wait until USART0_RXDATAL_packet_done;
                        end if;
                    end if;
                end if;
            end loop;
        else
            file_close(data_file_USART0_RXDATAL);
            wait;
        end if;
        file_close(data_file_USART0_RXDATAL);
    end process XBEE_DOUT;

end testbench;
